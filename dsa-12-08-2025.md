# DSA Concepts Recap – 2025-08-12

This document summarizes the discussion points and algorithmic intuition we covered today for four topics:

1. **Lowest Common Ancestor (LCA)**
2. **Cycle Detection in Graphs**
3. **LRU Cache**
4. **Dijkstra's Algorithm**

---

## 1. Lowest Common Ancestor (LCA)

**Problem:**  
Given two nodes `p` and `q` in a binary tree, find their lowest common ancestor (the deepest node that is an ancestor of both).

**DFS Approach:**
- Base case: If current node is `null`, return `null`.
- If current node matches `p` or `q`, return current node.
- Recursively check **left** and **right** subtrees.
- If **both** sides return non-null, current node is the LCA.
- If only one side returns non-null, propagate that upwards.

**Key Points:**
- Works in O(N) time.
- Can be extended to store parent pointers or preprocess with Binary Lifting for multiple queries.

---

## 2. Cycle Detection in Undirected Graphs

**DFS Method:**
- Maintain a `visited[]` array.
- Pass the `parent` node along with `source` during DFS.
- If you encounter an already visited neighbor that is **not** the parent, a cycle exists.

**BFS Method:**
- Use a queue of pairs `(node, parent)`.
- For each neighbor:
  - If unvisited, push `(neighbor, current)` into queue.
  - If visited and not equal to parent, cycle exists.

**Key Points:**
- This is the standard **graph traversal with parent tracking**.
- Works for undirected graphs; for directed graphs, use **DFS recursion stack** or **Kahn’s Algorithm**.

---

## 3. LRU Cache

**Goal:**  
Design a data structure to store key-value pairs with:
- O(1) `get(key)`
- O(1) `put(key, value)`
- Remove least recently used (LRU) item when capacity is reached.

**Approach:**
- **Doubly Linked List**: Store items in order of usage.
- **Hash Map**: Map keys → corresponding linked list nodes for O(1) access.
- On `get`:
  - If not found, return -1.
  - If found, move node to front (most recently used).
- On `put`:
  - If key exists, update value and move to front.
  - If new key and capacity is full, remove tail node, erase from map.
  - Insert new node at head and store in map.

**Key Points:**
- Combination of HashMap + DLL gives O(1) for both operations.
- Moving nodes requires pointer re-linking, not re-creation.

---

## 4. Dijkstra's Algorithm

**Goal:**  
Find shortest distances from a source node to all nodes in a weighted graph (non-negative edges).

**Steps:**
1. Initialize `dist[]` with `∞`, set `dist[source] = 0`.
2. Use a **min-heap priority queue** storing `(distance, node)`.
3. While queue is not empty:
   - Extract node with smallest distance.
   - For each neighbor `(v, weight)`:
     - If `dist[v] > dist[u] + weight`, update `dist[v]` and push into queue.

**Complexity:**
- **O((V + E) log V)** with adjacency list + min-heap.
  - `(V + E)` relaxations.
  - `log V` for heap operations.

**Key Points:**
- Similar to BFS, but with priority queue for weighted graphs.
- With adjacency matrix, complexity becomes O(V²).

---

**Author's Note:**  
These summaries are meant as a quick refresher. The core ideas focus on **intuition + approach** rather than full code, to help you recall the reasoning during interviews or revision.
